<!DOCTYPE html>
<html class="writer-html5" lang="english" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How does it work? &mdash; cp-sat primer 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=14667faf"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Benchmarking your Model" href="06_benchmarking-your-model.html" />
    <link rel="prev" title="Parameters" href="04_parameters.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            cp-sat primer
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00_introduction.html">Using and Understanding ortools' CP-SAT: A Primer and Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_example.html">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_modelling.html">Modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_parameters.html">Parameters</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">How does it work?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-happens-in-cp-sat-on-solve">What happens in CP-SAT on solve?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-use-of-linear-programming-techniques">The use of linear programming techniques</a></li>
<li class="toctree-l2"><a class="reference internal" href="#limitations-of-cp-sat">Limitations of CP-SAT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="06_benchmarking-your-model.html">Benchmarking your Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_large-neighborhood-search.html">Using CP-SAT for Bigger Problems with Large Neighborhood Search</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cp-sat primer</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">How does it work?</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/05_how-does-it-work.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="how-does-it-work">
<h1>How does it work?<a class="headerlink" href="#how-does-it-work" title="Link to this heading"></a></h1>
<p>CP-SAT is a versatile <em>portfolio</em> solver, centered around a <em>Lazy Clause
Generation (LCG)</em> based Constraint Programming Solver, although it encompasses a
broader spectrum of technologies.</p>
<p>In its role as a portfolio solver, CP-SAT concurrently executes a multitude of
diverse algorithms and strategies, each possessing unique strengths and
weaknesses. These elements operate largely independently but engage in
information exchange, sharing progress when better solutions emerge or tighter
bounds become available.</p>
<p>While this may initially appear as an inefficient approach due to potential
redundancy, it proves highly effective in practice. The rationale behind this
lies in the inherent challenge of predicting which algorithm is best suited to
solve a given problem (No Free Lunch Theorem). Thus, the pragmatic strategy
involves running various approaches in parallel, with the hope that one will
effectively address the problem at hand. Note that you can also specify which
algorithms should be used if you already know which strategies are promising or
futile.</p>
<p>In contrast, Branch and Cut-based Mixed Integer Programming solvers like Gurobi
implement a more efficient partitioning of the search space to reduce
redundancy. However, they specialize in a particular strategy, which may not
always be the optimal choice, although it frequently proves to be so.</p>
<p>CP-SAT employs Branch and Cut techniques, including linear relaxations and
cutting planes, as part of its toolkit. Models that can be efficiently addressed
by a Mixed Integer Programming (MIP) solver are typically a good match for
CP-SAT as well. Nevertheless, CP-SAT's central focus is the implementation of
Lazy Clause Generation, harnessing SAT-solvers rather than relying primarily on
linear relaxations. As a result, CP-SAT may exhibit somewhat reduced performance
when confronted with MIP problems compared to dedicated MIP solvers. However, it
gains a distinct advantage when dealing with problems laden with intricate
logical constraints.</p>
<p>The concept behind Lazy Clause Generation involves the (incremental)
transformation of the problem into a SAT-formula, subsequently employing a
SAT-solver to seek a solution (or prove bounds by infeasibility). To mitigate
the impracticality of a straightforward conversion, Lazy Clause Generation
leverages an abundance of lazy variables and clauses.</p>
<p>Notably, the
<a class="reference external" href="https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem">Cook-Levin Theorem</a>
attests that any problem within the realm of NP can be translated into a
SAT-formula. Optimization, in theory, could be achieved through a simple binary
search. However, this approach, while theoretically sound, lacks efficiency.
CP-SAT employs a more refined encoding scheme to tackle optimization problems
more effectively.</p>
<p>If you want to understand the inner workings of CP-SAT, you can follow the
following learning path:</p>
<ol class="arabic simple">
<li><p>Learn how to get a feasible solution based on boolean logics with
SAT-solvers: Backtracking, DPLL, CDCL, VSIDS, ...</p>
<ul class="simple">
<li><p><a class="reference external" href="https://youtu.be/DU44Y9Pt504">Historical Overview by Armin Biere</a> (video)</p></li>
<li><p><a class="reference external" href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html">Donald Knuth - The Art of Computer Programming, Volume 4, Fascicle 6: Satisfiability</a>
(book)</p></li>
<li><p><a class="reference external" href="https://baldur.iti.kit.edu/sat/#about">Carsten Sinz and Tomas Baylo - Practical SAT Solving</a>
(slides)</p></li>
</ul>
</li>
<li><p>Learn how to get provably optimal solutions via classical Mixed Integer
Programming:</p>
<ul class="simple">
<li><p>Linear Programming: Simplex, Duality, Dual Simplex, ...</p>
<ul>
<li><p><a class="reference external" href="https://link.springer.com/book/10.1007/978-3-540-30717-4">Understanding and Using Linear Programming</a>
(book)</p></li>
</ul>
</li>
<li><p>Mixed Integer Programming: Branch and Bound, Cutting Planes, Branch and
Cut, ...</p>
<ul>
<li><p><a class="reference external" href="https://www.coursera.org/learn/discrete-optimization">Discrete Optimization on Coursera</a>
(video course)</p></li>
<li><p><a class="reference external" href="https://www.gurobi.com/resource/mip-basics/">Gurobi Resources</a> (website)</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Learn the additional concepts of LCG Constraint Programming: Propagation,
Lazy Clause Generation, ...</p>
<ul class="simple">
<li><p><a class="reference external" href="https://user.it.uu.se/~pierref/courses/COCP/slides/">Combinatorial Optimisation and Constraint Programming by Prof. Pierre Flener at Uppsala University in Sweden</a>
(slides)</p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=lxiCHRFNgno">Talk by Peter Stuckey</a>
(video)</p></li>
<li><p><a class="reference external" href="https://people.eng.unimelb.edu.au/pstuckey/papers/cp09-lc.pdf">Paper on Lazy Clause Generation</a>
(paper)</p></li>
</ul>
</li>
<li><p>Learn the details of CP-SAT:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/google/or-tools/blob/stable/ortools/sat/sat_parameters.proto">The proto-file of the parameters</a>
(source)</p></li>
<li><p><a class="reference external" href="https://github.com/google/or-tools/tree/stable/ortools/sat">The complete source code</a>
(source)</p></li>
<li><p><a class="reference external" href="https://youtu.be/lmy1ddn4cyw">A talk by the developers of CP-SAT</a> (video)</p></li>
</ul>
</li>
</ol>
<p>If you already have a background in Mixed Integer Programming, you may directly
jump into the slides of
<a class="reference external" href="https://user.it.uu.se/~pierref/courses/COCP/slides/">Combinatorial Optimisation and Constraint Programming</a>.
This is a full and detailed course on constraint programming, and will probably
take you some time to work through. However, it gives you all the knowledge you
need to understand the constraint programming part of CP-SAT.</p>
<blockquote>
<div><p>Originally, I wrote a short introduction into each of the topics, but I
decided to remove them as the material I linked to is much better than what I
could have written. You can find a backup of the old version
<span class="xref myst">here</span>.</p>
</div></blockquote>
<section id="what-happens-in-cp-sat-on-solve">
<h2>What happens in CP-SAT on solve?<a class="headerlink" href="#what-happens-in-cp-sat-on-solve" title="Link to this heading"></a></h2>
<p>What actually happens when you execute <code class="docutils literal notranslate"><span class="pre">solver.Solve(model)</span></code>?</p>
<ol class="arabic simple">
<li><p>The model is read.</p></li>
<li><p>The model is verified.</p></li>
<li><p>Preprocessing (multiple iterations):</p>
<ol class="arabic simple">
<li><p>Presolve (domain reduction)</p></li>
<li><p>Expanding higher-level constraints to lower-level constraints. See also
the analogous
<a class="reference external" href="https://www.minizinc.org/doc-2.5.5/en/flattening.html">FlatZinc and Flattening</a>.</p></li>
<li><p>Detection of equivalent variables and
<a class="reference external" href="https://personal.math.ubc.ca/~cass/courses/m309-03a/a1/olafson/affine_fuctions.htm">affine relations</a>.</p></li>
<li><p>Substitute these by canonical representations</p></li>
<li><p>Probe some variables to detect if they are actually fixed or detect
further equivalences.</p></li>
</ol>
</li>
<li><p>Load the preprocessed model into the underlying solver and create the linear
relaxations.</p></li>
<li><p><strong>Search for solutions and bounds with the different solvers until the lower
and upper bound match or another termination criterion is reached (e.g., time
limit)</strong></p></li>
<li><p>Transform solution back to original model.</p></li>
</ol>
<p>This is taken from <a class="reference external" href="https://youtu.be/lmy1ddn4cyw?t=434">this talk</a> and slightly
extended.</p>
</section>
<section id="the-use-of-linear-programming-techniques">
<h2>The use of linear programming techniques<a class="headerlink" href="#the-use-of-linear-programming-techniques" title="Link to this heading"></a></h2>
<p>As already mentioned before, CP-SAT also utilizes the (dual) simplex algorithm
and linear relaxations. The linear relaxation is implemented as a propagator and
potentially executed at every node in the search tree but only at lowest
priority. A significant difference to the application of linear relaxations in
branch and bound algorithms is that only some pivot iterations are performed (to
make it faster). However, as there are likely much deeper search trees and the
warm-starts are utilized, the optimal linear relaxation may still be computed,
just deeper down the tree (note that for SAT-solving, the search tree is usually
traversed DFS). At root level, even cutting planes such as Gomory-Cuts are
applied to improve the linear relaxation.</p>
<p>The linear relaxation is used for detecting infeasibility (IPs can actually be
more powerful than simple SAT, at least in theory), finding better bounds for
the objective and variables, and also for making branching decisions (using the
linear relaxation's objective and the reduced costs).</p>
<p>The used Relaxation Induced Neighborhood Search RINS (LNS worker), a very
successful heuristic, of course also uses linear programming.</p>
</section>
<section id="limitations-of-cp-sat">
<h2>Limitations of CP-SAT<a class="headerlink" href="#limitations-of-cp-sat" title="Link to this heading"></a></h2>
<p>While CP-SAT is undeniably a potent solver, it does possess certain limitations
when juxtaposed with alternative techniques:</p>
<ol class="arabic simple">
<li><p>While proficient, it may not match the speed of a dedicated SAT-solver when
tasked with solving SAT-formulas, although its performance remains quite
commendable.</p></li>
<li><p>Similarly, for classical MIP-problems, CP-SAT may not outpace dedicated
MIP-solvers in terms of speed, although it still delivers respectable
performance.</p></li>
<li><p>Unlike MIP/LP-solvers, CP-SAT lacks support for continuous variables, and the
workarounds to incorporate them may not always be highly efficient. In cases
where your problem predominantly features continuous variables and linear
constraints, opting for an LP-solver is likely to yield significantly
improved performance.</p></li>
<li><p>CP-SAT does not offer support for lazy constraints or iterative model
building, a feature available in MIP/LP-solvers and select SAT-solvers.
Consequently, the application of exponential-sized models, which are common
and pivotal in Mixed Integer Programming, may be restricted.</p></li>
<li><p>CP-SAT is limited to the Simplex algorithm and does not feature interior
point methods. This limitation prevents it from employing polynomial time
algorithms for certain classes of quadratic constraints, such as Second Order
Cone constraints. In contrast, solvers like Gurobi utilize the Barrier
algorithm to efficiently tackle these constraints in polynomial time.</p></li>
</ol>
<p>CP-SAT might also exhibit inefficiency when confronted with certain constraints,
such as modulo constraints. However, it's noteworthy that I am not aware of any
alternative solver capable of efficiently addressing these specific constraints.
At times, NP-hard problems inherently pose formidable challenges, leaving us
with no alternative but to seek more manageable modeling approaches instead of
looking for better solvers.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="04_parameters.html" class="btn btn-neutral float-left" title="Parameters" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="06_benchmarking-your-model.html" class="btn btn-neutral float-right" title="Benchmarking your Model" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Dominik Krupke (TU Braunschweig, IBR, Algorithms Group).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>